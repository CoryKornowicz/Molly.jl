<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · Molly.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Molly.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li><a class="tocitem" href="#Simulation-basics"><span>Simulation basics</span></a></li><li><a class="tocitem" href="#GPU-acceleration"><span>GPU acceleration</span></a></li><li><a class="tocitem" href="#Simulating-diatomic-molecules"><span>Simulating diatomic molecules</span></a></li><li><a class="tocitem" href="#Simulating-gravity"><span>Simulating gravity</span></a></li><li><a class="tocitem" href="#Simulating-a-protein"><span>Simulating a protein</span></a></li><li><a class="tocitem" href="#Agent-based-modelling"><span>Agent-based modelling</span></a></li><li><a class="tocitem" href="#Units"><span>Units</span></a></li><li><a class="tocitem" href="#Forces"><span>Forces</span></a></li><li><a class="tocitem" href="#Cutoffs"><span>Cutoffs</span></a></li><li><a class="tocitem" href="#Simulators"><span>Simulators</span></a></li><li><a class="tocitem" href="#Coupling"><span>Coupling</span></a></li><li><a class="tocitem" href="#Neighbor-finders"><span>Neighbor finders</span></a></li><li><a class="tocitem" href="#Loggers"><span>Loggers</span></a></li><li><a class="tocitem" href="#Analysis"><span>Analysis</span></a></li></ul></li><li><a class="tocitem" href="../differentiable/">Differentiable simulation</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMolSim/Molly.jl/blob/master/docs/src/docs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Molly-documentation"><a class="docs-heading-anchor" href="#Molly-documentation">Molly documentation</a><a id="Molly-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Molly-documentation" title="Permalink"></a></h1><p>This documentation will first introduce the main features of the package with some examples, then will give details on each component of a simulation. There are further examples in the <a href="../examples/#Molly-examples">Molly examples</a> section. For more information on specific types or functions, see the <a href="../api/#Molly-API">Molly API</a> section or call <code>?function_name</code> in Julia. The <a href="../differentiable/#Differentiable-simulation-with-Molly">Differentiable simulation with Molly</a> section describes taking gradients through simulations.</p><p>Molly takes a modular approach to molecular simulation. To run a simulation you create a <a href="../api/#Molly.System"><code>System</code></a> object and call <a href="../api/#Molly.simulate!-Tuple{Any, VelocityVerlet, Integer}"><code>simulate!</code></a> on it. The different components of the system and simulation can be used as defined by the package, or you can define your own versions. An important principle of the package is that your custom components, particularly force functions, should be easy to define and just as performant as the built-in versions.</p><h2 id="Simulation-basics"><a class="docs-heading-anchor" href="#Simulation-basics">Simulation basics</a><a id="Simulation-basics-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-basics" title="Permalink"></a></h2><p>Let&#39;s look at the simulation of a fluid acting under the <a href="https://en.wikipedia.org/wiki/Lennard-Jones_potential">Lennard-Jones</a> potential to start with. First, we&#39;ll need some atoms with the relevant parameters defined.</p><pre><code class="language-julia">using Molly

n_atoms = 100
atom_mass = 10.0u&quot;u&quot;
atoms = [Atom(mass=atom_mass, σ=0.3u&quot;nm&quot;, ϵ=0.2u&quot;kJ * mol^-1&quot;) for i in 1:n_atoms]</code></pre><p>See the <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a> docs for more information on the unit annotations. Molly re-exports Unitful.jl and <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> since they are usually required to run simulations. Next, we&#39;ll need some starting coordinates and velocities.</p><pre><code class="language-julia">box_size = SVector(2.0, 2.0, 2.0)u&quot;nm&quot;
coords = place_atoms(n_atoms, box_size, 0.3u&quot;nm&quot;) # Random placement without clashing

temp = 100.0u&quot;K&quot;
velocities = [velocity(atom_mass, temp) for i in 1:n_atoms]</code></pre><p>We store the coordinates and velocities as <a href="https://github.com/JuliaArrays/StaticArrays.jl">static arrays</a> for performance. They can be of 2 or 3 dimensions and of any number type, e.g. <code>Float64</code> or <code>Float32</code>. Now we can define our pairwise interactions, i.e. those between most or all atom pairs. Because we have defined the relevant parameters for the atoms, we can use the built-in Lennard-Jones type.</p><pre><code class="language-julia">pairwise_inters = (LennardJones(),)</code></pre><p>Finally, we can define the system and run the simulation. We use an Andersen thermostat to keep a constant temperature, and we log the temperature and coordinates every 10 steps. Periodic boundary conditions are used with the box we defined earlier.</p><pre><code class="language-julia">sys = System(
    atoms=atoms,
    pairwise_inters=pairwise_inters,
    coords=coords,
    velocities=velocities,
    box_size=box_size,
    loggers=Dict(
        &quot;temp&quot;   =&gt; TemperatureLogger(10),
        &quot;coords&quot; =&gt; CoordinateLogger(10),
    ),
)

simulator = VelocityVerlet(dt=0.002u&quot;ps&quot;, coupling=AndersenThermostat(temp, 1.0u&quot;ps&quot;))
simulate!(sys, simulator, 1_000)</code></pre><p>By default the simulation is run in parallel on the <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#man-multithreading-1">number of threads</a> available to Julia, but this can be turned off by giving the keyword argument <code>parallel=false</code> to <a href="../api/#Molly.simulate!-Tuple{Any, VelocityVerlet, Integer}"><code>simulate!</code></a>. An animation of the stored coordinates using can be saved using <a href="../api/#Molly.visualize"><code>visualize</code></a>, which is available when <a href="https://github.com/JuliaPlots/Makie.jl">GLMakie.jl</a> is imported.</p><pre><code class="language-julia">using GLMakie
visualize(sys.loggers[&quot;coords&quot;], box_size, &quot;sim_lj.mp4&quot;)</code></pre><p><img src="../images/sim_lj.gif" alt="LJ simulation"/></p><h2 id="GPU-acceleration"><a class="docs-heading-anchor" href="#GPU-acceleration">GPU acceleration</a><a id="GPU-acceleration-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-acceleration" title="Permalink"></a></h2><p>To run simulations on the GPU you will need to have a CUDA-compatible device and to have <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> installed. Simulation setup is similar to above, but with the coordinates, velocities and atoms moved to the GPU. This example also shows setting up a simulation to run with <code>Float32</code>, which can be a good idea for GPUs.</p><pre><code class="language-julia">using Molly
using CUDA

n_atoms = 100
atom_mass = 10.0f0u&quot;u&quot;
box_size = SVector(2.0f0, 2.0f0, 2.0f0)u&quot;nm&quot;
temp = 100.0f0u&quot;K&quot;
atoms = cu([Atom(mass=atom_mass, σ=0.3f0u&quot;nm&quot;, ϵ=0.2f0u&quot;kJ * mol^-1&quot;) for i in 1:n_atoms])
coords = cu(place_atoms(n_atoms, box_size, 0.3u&quot;nm&quot;))
velocities = cu([velocity(atom_mass, temp) for i in 1:n_atoms])
simulator = VelocityVerlet(dt=0.002f0u&quot;ps&quot;)

sys = System(
    atoms=atoms,
    pairwise_inters=(LennardJones(),),
    coords=coords,
    velocities=velocities,
    box_size=box_size,
    loggers=Dict(
        &quot;temp&quot;   =&gt; TemperatureLogger(typeof(1.0f0u&quot;K&quot;), 10),
        &quot;coords&quot; =&gt; CoordinateLogger(typeof(1.0f0u&quot;nm&quot;), 10),
    ),
)

simulate!(sys, simulator, 1_000)</code></pre><h2 id="Simulating-diatomic-molecules"><a class="docs-heading-anchor" href="#Simulating-diatomic-molecules">Simulating diatomic molecules</a><a id="Simulating-diatomic-molecules-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-diatomic-molecules" title="Permalink"></a></h2><p>If we want to define specific interactions between atoms, for example bonds, we can do. Using the same definitions as the first example, let&#39;s set up the coordinates so that paired atoms are 1 Å apart.</p><pre><code class="language-julia">coords = place_atoms(n_atoms ÷ 2, box_size, 0.3u&quot;nm&quot;)
for i in 1:length(coords)
    push!(coords, coords[i] .+ [0.1, 0.0, 0.0]u&quot;nm&quot;)
end

velocities = [velocity(atom_mass, temp) for i in 1:n_atoms]</code></pre><p>Now we can use the built-in interaction list and bond types to place harmonic bonds between paired atoms.</p><pre><code class="language-julia">bonds = InteractionList2Atoms(
    collect(1:(n_atoms ÷ 2)),
    collect((1 + n_atoms ÷ 2):n_atoms),
    repeat([&quot;&quot;], n_atoms ÷ 2),
    [HarmonicBond(b0=0.1u&quot;nm&quot;, kb=300_000.0u&quot;kJ * mol^-1 * nm^-2&quot;) for i in 1:(n_atoms ÷ 2)],
)

specific_inter_lists = (bonds,)</code></pre><p>This time, we are also going to use a neighbor list to speed up the Lennard Jones calculation. We can use the built-in distance neighbor finder. The arguments are a 2D array of eligible interacting pairs, the number of steps between each update and the cutoff to be classed as a neighbor.</p><pre><code class="language-julia"># All pairs apart from bonded pairs are eligible to interact
nb_matrix = trues(n_atoms, n_atoms)
for i in 1:(n_atoms ÷ 2)
    nb_matrix[i, i + (n_atoms ÷ 2)] = false
    nb_matrix[i + (n_atoms ÷ 2), i] = false
end

neighbor_finder = DistanceNeighborFinder(
    nb_matrix=nb_matrix,
    n_steps=10,
    dist_cutoff=1.5u&quot;nm&quot;,
)</code></pre><p>Now we can simulate as before.</p><pre><code class="language-julia">sys = System(
    atoms=atoms,
    pairwise_inters=(LennardJones(nl_only=true),),
    specific_inter_lists=specific_inter_lists,
    coords=coords,
    velocities=velocities,
    box_size=box_size,
    neighbor_finder=neighbor_finder,
    loggers=Dict(
        &quot;temp&quot; =&gt; TemperatureLogger(10),
        &quot;coords&quot; =&gt; CoordinateLogger(10),
    ),
)

simulator = VelocityVerlet(
    dt=0.002u&quot;ps&quot;,
    coupling=AndersenThermostat(temp, 1.0u&quot;ps&quot;),
)
simulate!(sys, simulator, 1_000)</code></pre><p>This time when we view the trajectory we can add lines to show the bonds.</p><pre><code class="language-julia">visualize(
    sys.loggers[&quot;coords&quot;],
    box_size,
    &quot;sim_diatomic.mp4&quot;;
    connections=[(i, i + (n_atoms ÷ 2)) for i in 1:(n_atoms ÷ 2)],
)</code></pre><p><img src="../images/sim_diatomic.gif" alt="Diatomic simulation"/></p><h2 id="Simulating-gravity"><a class="docs-heading-anchor" href="#Simulating-gravity">Simulating gravity</a><a id="Simulating-gravity-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-gravity" title="Permalink"></a></h2><p>Molly is geared primarily to molecular simulation, but can also be used to simulate other physical systems. Let&#39;s set up a gravitational simulation. This example also shows the use of <code>Float32</code>, a 2D simulation and no specified units.</p><pre><code class="language-julia">atoms = [Atom(mass=1.0f0), Atom(mass=1.0f0)]
coords = [SVector(0.3f0, 0.5f0), SVector(0.7f0, 0.5f0)]
velocities = [SVector(0.0f0, 1.0f0), SVector(0.0f0, -1.0f0)]
pairwise_inters = (Gravity(nl_only=false, G=1.5f0),)
simulator = VelocityVerlet(dt=0.002f0)
box_size = SVector(1.0f0, 1.0f0)

sys = System(
    atoms=atoms,
    pairwise_inters=pairwise_inters,
    coords=coords,
    velocities=velocities,
    box_size=box_size,
    loggers=Dict(&quot;coords&quot; =&gt; CoordinateLogger(Float32, 10; dims=2)),
    force_units=NoUnits,
    energy_units=NoUnits,
)

simulate!(sys, simulator, 2_000)</code></pre><p>When we view the simulation we can use some extra options:</p><pre><code class="language-julia">visualize(
    sys.loggers[&quot;coords&quot;],
    box_size,
    &quot;sim_gravity.mp4&quot;;
    trails=4,
    framerate=15,
    color=[:orange, :lightgreen],
)</code></pre><p><img src="../images/sim_gravity.gif" alt="Gravity simulation"/></p><h2 id="Simulating-a-protein"><a class="docs-heading-anchor" href="#Simulating-a-protein">Simulating a protein</a><a id="Simulating-a-protein-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-a-protein" title="Permalink"></a></h2><p>The recommended way to simulate a macromolecular simulation is to read in a force field in OpenMM XML format and read in a coordinate file in a format <a href="https://chemfiles.org/chemfiles/latest/formats.html">supported by Chemfiles.jl</a>. This sets up a system in the same data structures as above and is simulated in the same way. Here a <a href="../api/#Molly.StructureWriter"><code>StructureWriter</code></a> is used to write the trajectory as a PDB file.</p><pre><code class="language-julia">ff = OpenMMForceField(&quot;ff99SBildn.xml&quot;, &quot;tip3p_standard.xml&quot;, &quot;his.xml&quot;)

sys = System(
    &quot;6mrr_equil.pdb&quot;,
    ff;
    loggers=Dict(
        &quot;energy&quot; =&gt; TotalEnergyLogger(10),
        &quot;writer&quot; =&gt; StructureWriter(10, &quot;traj_6mrr_1ps.pdb&quot;, [&quot;HOH&quot;]),
    ),
)

random_velocities!(sys, 298.0u&quot;K&quot;)
simulator = VelocityVerlet(dt=0.0005u&quot;ps&quot;)

simulate!(sys, simulator, 5_000; parallel=true)</code></pre><p>You can use an implicit solvent method by giving the <code>implicit_solvent</code> keyword argument to <a href="../api/#Molly.System"><code>System</code></a>. The options are <code>&quot;obc1&quot;</code> and <code>&quot;obc2&quot;</code>, corresponding to the Onufriev-Bashford-Case GBSA model with parameter set I or II. Other options include overriding the box size in the file (<code>box_size</code>) and modifying the non-bonded interaction and neighbor list cutoff distances (<code>dist_cutoff</code> and <code>nl_dist</code>).</p><p>Molly also has a rudimentary parser of <a href="http://www.gromacs.org">Gromacs</a> topology and coordinate files.</p><pre><code class="language-julia">sys = System(
    joinpath(dirname(pathof(Molly)), &quot;..&quot;, &quot;data&quot;, &quot;5XER&quot;, &quot;gmx_coords.gro&quot;),
    joinpath(dirname(pathof(Molly)), &quot;..&quot;, &quot;data&quot;, &quot;5XER&quot;, &quot;gmx_top_ff.top&quot;);
    loggers=Dict(
        &quot;temp&quot;   =&gt; TemperatureLogger(10),
        &quot;writer&quot; =&gt; StructureWriter(10, &quot;traj_5XER_1ps.pdb&quot;),
    ),
)

temp = 298.0u&quot;K&quot;
random_velocities!(sys, temp)
simulator = VelocityVerlet(dt=0.0002u&quot;ps&quot;, coupling=AndersenThermostat(temp, 1.0u&quot;ps&quot;))

simulate!(sys, simulator, 5_000)</code></pre><h2 id="Agent-based-modelling"><a class="docs-heading-anchor" href="#Agent-based-modelling">Agent-based modelling</a><a id="Agent-based-modelling-1"></a><a class="docs-heading-anchor-permalink" href="#Agent-based-modelling" title="Permalink"></a></h2><p>Agent-based modelling (ABM) is conceptually similar to molecular dynamics. Julia has <a href="https://juliadynamics.github.io/Agents.jl/stable/">Agents.jl</a> for ABM, but Molly can also be used to simulate arbitrary agent-based systems in continuous space. Here we simulate a toy SIR model for disease spread. This example shows how atom properties can be mutable, i.e. change during the simulation, and includes custom forces and loggers (see below for more).</p><pre><code class="language-julia">@enum Status susceptible infected recovered

# Custom atom type
mutable struct Person
    i::Int
    status::Status
    mass::Float64
    σ::Float64
    ϵ::Float64
end

Molly.mass(person::Person) = person.mass

# Custom PairwiseInteraction
struct SIRInteraction &lt;: PairwiseInteraction
    nl_only::Bool
    dist_infection::Float64
    prob_infection::Float64
    prob_recovery::Float64
end

# Custom force function
function Molly.force(inter::SIRInteraction,
                        vec_ij,
                        coord_i,
                        coord_j,
                        atom_i,
                        atom_j,
                        box_size)
    if (atom_i.status == infected &amp;&amp; atom_j.status == susceptible) ||
                (atom_i.status == susceptible &amp;&amp; atom_j.status == infected)
        # Infect close people randomly
        r2 = sum(abs2, vec_ij)
        if r2 &lt; inter.dist_infection ^ 2 &amp;&amp; rand() &lt; inter.prob_infection
            atom_i.status = infected
            atom_j.status = infected
        end
    end
    # Workaround to obtain a self-interaction
    if atom_i.i == (atom_j.i + 1)
        # Recover randomly
        if atom_i.status == infected &amp;&amp; rand() &lt; inter.prob_recovery
            atom_i.status = recovered
        end
    end
    return zero(coord_i)
end

# Custom Logger
struct SIRLogger
    n_steps::Int
    fracs_sir::Vector{Vector{Float64}}
end

# Custom logging function
function Molly.log_property!(logger::SIRLogger, s, neighbors, step_n)
    if step_n % logger.n_steps == 0
        counts_sir = [
            count(p -&gt; p.status == susceptible, s.atoms),
            count(p -&gt; p.status == infected   , s.atoms),
            count(p -&gt; p.status == recovered  , s.atoms)
        ]
        push!(logger.fracs_sir, counts_sir ./ length(s))
    end
end

temp = 1.0
box_size = SVector(10.0, 10.0)
n_steps = 1_000
n_people = 500
n_starting = 2
atoms = [Person(i, i &lt;= n_starting ? infected : susceptible, 1.0, 0.1, 0.02) for i in 1:n_people]
coords = place_atoms(n_people, box_size, 0.1)
velocities = [velocity(1.0, temp; dims=2) for i in 1:n_people]
pairwise_inters = (LennardJones=LennardJones(nl_only=true), SIR=SIRInteraction(false, 0.5, 0.06, 0.01))
neighbor_finder = DistanceNeighborFinder(nb_matrix=trues(n_people, n_people), n_steps=10, dist_cutoff=2.0)
simulator = VelocityVerlet(dt=0.02, coupling=AndersenThermostat(temp, 5.0))

sys = System(
    atoms=atoms,
    pairwise_inters=pairwise_inters,
    coords=coords,
    velocities=velocities,
    box_size=box_size,
    neighbor_finder=neighbor_finder,
    loggers=Dict(&quot;coords&quot; =&gt; CoordinateLogger(Float64, 10; dims=2),
                    &quot;SIR&quot; =&gt; SIRLogger(10, [])),
    force_units=NoUnits,
    energy_units=NoUnits,
)

simulate!(sys, simulator, n_steps)

visualize(sys.loggers[&quot;coords&quot;], box_size, &quot;sim_agent.mp4&quot;; markersize=0.1)</code></pre><p><img src="../images/sim_agent.gif" alt="Agent simulation"/></p><p>We can use the logger to plot the fraction of people susceptible (blue), infected (orange) and recovered (green) over the course of the simulation: <img src="../images/fraction_sir.png" alt="Fraction SIR"/></p><h2 id="Units"><a class="docs-heading-anchor" href="#Units">Units</a><a id="Units-1"></a><a class="docs-heading-anchor-permalink" href="#Units" title="Permalink"></a></h2><p>Molly is fairly opinionated about using <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a> units as shown above: you don&#39;t have to use them, but it is better if you do. Whilst you occasionally may run into friction with dimension mismatches, using units has the major advantages of catching whole classes of errors and letting you physically interpret the numbers in your system. The performance overhead of using units is minimal. Units are not currently compatible with differentiable simulations.</p><p>All your interaction types need to return the same units of force and energy or the simulation will not run. By default these are <code>kJ * mol^-1 * nm^-1</code> for force and <code>kJ * mol^-1</code> for energy, but this can be changed using the <code>force_units</code> and <code>energy_units</code> arguments to <a href="../api/#Molly.System"><code>System</code></a>. If you need to strip units for downstream analysis, use the <code>ustrip</code> function. It should be noted that charges are stored as dimensionless, i.e. 1.0 is an atomic charge of +1.</p><h2 id="Forces"><a class="docs-heading-anchor" href="#Forces">Forces</a><a id="Forces-1"></a><a class="docs-heading-anchor-permalink" href="#Forces" title="Permalink"></a></h2><p>Forces define how different parts of the system interact. The force on each particle in the system is derived from the potential corresponding to the interaction.</p><p class="math-container">\[\vec{F}_i = -\sum_j \frac{dV_{ij}(r_{ij})}{dr_{ij}}\frac{\vec{r}_{ij}}{r_{ij}}\]</p><p>In Molly there are three types of interactions:</p><ul><li><a href="../api/#Molly.PairwiseInteraction"><code>PairwiseInteraction</code></a>s are present between all or most atom pairs, and account for example for non-bonded terms.</li><li><a href="../api/#Molly.SpecificInteraction"><code>SpecificInteraction</code></a>s are present between specific atoms, and account for example for bonded terms.</li><li>General interactions are a free-form interaction type that can access the whole system and outputs forces for all atom. This is useful for neural network potentials and implicit solvent models.</li></ul><p>The available pairwise interactions are:</p><ul><li><a href="../api/#Molly.LennardJones"><code>LennardJones</code></a></li><li><a href="../api/#Molly.SoftSphere"><code>SoftSphere</code></a></li><li><a href="../api/#Molly.Mie"><code>Mie</code></a></li><li><a href="../api/#Molly.Coulomb"><code>Coulomb</code></a></li><li><a href="../api/#Molly.CoulombReactionField"><code>CoulombReactionField</code></a></li><li><a href="../api/#Molly.Gravity"><code>Gravity</code></a></li></ul><p>The available specific interactions are:</p><ul><li><a href="../api/#Molly.HarmonicBond"><code>HarmonicBond</code></a></li><li><a href="../api/#Molly.MorseBond"><code>MorseBond</code></a></li><li><a href="../api/#Molly.HarmonicAngle"><code>HarmonicAngle</code></a></li><li><a href="../api/#Molly.PeriodicTorsion"><code>PeriodicTorsion</code></a></li><li><a href="../api/#Molly.RBTorsion"><code>RBTorsion</code></a></li></ul><p>The available general interactions are:</p><ul><li><a href="../api/#Molly.ImplicitSolventOBC"><code>ImplicitSolventOBC</code></a></li></ul><h3 id="Pairwise-interactions"><a class="docs-heading-anchor" href="#Pairwise-interactions">Pairwise interactions</a><a id="Pairwise-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Pairwise-interactions" title="Permalink"></a></h3><p>To define your own <a href="../api/#Molly.PairwiseInteraction"><code>PairwiseInteraction</code></a>, first define the <code>struct</code>:</p><pre><code class="language-julia">struct MyPairwiseInter &lt;: PairwiseInteraction
    nl_only::Bool
    # Any other properties, e.g. constants for the interaction or cutoff parameters
end</code></pre><p>The <code>nl_only</code> property is required and determines whether the neighbor list is used to omit distant atoms (<code>true</code>) or whether all atom pairs are always considered (<code>false</code>). Next, you need to define the <a href="../api/#Molly.force"><code>force</code></a> function acting between a pair of atoms. This has a set series of arguments. For example:</p><pre><code class="language-julia">function Molly.force(inter::MyPairwiseInter,
                        vec_ij,
                        coord_i,
                        coord_j,
                        atom_i,
                        atom_j,
                        box_size)
    # Replace this with your force calculation
    # A positive force causes the atoms to move apart
    f = 0.0

    # Obtain a vector for the force
    fdr = f * normalize(vec_ij)
    return fdr
end</code></pre><p><code>vec_ij</code> is the vector between the closest images of atoms <code>i</code> and <code>j</code> accounting for the periodic boundary conditions. Atom properties can be accessed, e.g. <code>atom_i.σ</code>. Typically the force function is where most computation time is spent during the simulation, so consider optimising this function if you want high performance.</p><p>To use your custom force in a simulation, add it to the list of pairwise interactions:</p><pre><code class="language-julia">pairwise_inters = (MyPairwiseInter(true),)</code></pre><p>Then create a <a href="../api/#Molly.System"><code>System</code></a> and simulate as above. Note that you can also use named tuples instead of tuples if you want to access interactions by name:</p><pre><code class="language-julia">pairwise_inters = (MyPairwiseInter=MyPairwiseInter(true),)</code></pre><p>For performance reasons it is best to <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-abstract-container-1">avoid containers with abstract type parameters</a>, such as <code>Vector{PairwiseInteraction}</code>.</p><p>If you wish to calculate potential energies or log the energy throughout a simulation, define the <a href="../api/#Molly.potential_energy-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}, Tuple{System{D, G, T}, Any}} where {D, G, T}"><code>potential_energy</code></a> function. This has the same arguments as <a href="../api/#Molly.force"><code>force</code></a> and should return a single value corresponding to the potential energy.</p><h3 id="Specific-interactions"><a class="docs-heading-anchor" href="#Specific-interactions">Specific interactions</a><a id="Specific-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-interactions" title="Permalink"></a></h3><p>To define your own <a href="../api/#Molly.SpecificInteraction"><code>SpecificInteraction</code></a>, first define the <code>struct</code>:</p><pre><code class="language-julia">struct MySpecificInter &lt;: SpecificInteraction
    # Properties, e.g. a bond distance corresponding to the energy minimum
end</code></pre><p>Next, you need to define the <a href="../api/#Molly.force"><code>force</code></a> function. The form of this will depend whether the interaction involves 2, 3 or 4 atoms. For example in the 2 atom case:</p><pre><code class="language-julia">function Molly.force(inter::MySpecificInter, coords_i, coords_j, box_size)
    dr = vector(coords_i, coords_j, box_size)

    # Replace this with your force calculation
    # A positive force causes the atoms to move apart
    f = 0.0

    fdr = f * normalize(dr)
    return SpecificForce2Atoms(-fdr, fdr)
end</code></pre><p>The 3 atom case would define <code>Molly.force(inter::MySpecificInter, coords_i, coords_j, coords_k, box_size)</code> and return <code>SpecificForce3Atoms(f1, f2, f3)</code>. To use your custom force, add it to the specific interaction lists along with the atom indices:</p><pre><code class="language-julia">specific_inter_lists = (
    InteractionList2Atoms(
        [1, 3],
        [2, 4],
        [&quot;&quot;, &quot;&quot;],
        [MySpecificInter(), MySpecificInter()],
    ),
)</code></pre><p>For 3 atom interactions use <code>InteractionList3Atoms</code> and pass 3 sets of indices. If using the GPU, the inner list of interactions should be moved to the GPU.</p><h3 id="General-interactions"><a class="docs-heading-anchor" href="#General-interactions">General interactions</a><a id="General-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#General-interactions" title="Permalink"></a></h3><p>To define your own general interaction, first define the <code>struct</code>:</p><pre><code class="language-julia">struct MyGeneralInter
    # Properties, e.g. a neural network model
end</code></pre><p>Next, you need to define the <a href="../api/#Molly.forces-Union{Tuple{System{D, false}}, Tuple{D}, Tuple{System{D, false}, Any}} where D"><code>forces</code></a> function (note this is different to the <a href="../api/#Molly.force"><code>force</code></a> function above).</p><pre><code class="language-julia">function Molly.forces(inter::MyGeneralInter, sys, neighbors=nothing)
    # Calculate the forces on all atoms using the interaction and the system
    # The output should have the same shape as the coordinates
    # For example, a neural network might do something like this
    return inter.model(sys.coords, sys.atoms)
end</code></pre><p>The neighbors calculated from the neighbor list are available in this function, but may or may not be used depending on context. You can also define a <a href="../api/#Molly.potential_energy-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}, Tuple{System{D, G, T}, Any}} where {D, G, T}"><code>potential_energy</code></a> function that takes the same arguments and returns a single value. To use your custom force in a simulation, add it to the list of general interactions:</p><pre><code class="language-julia">general_inters = (MyGeneralInter(),)</code></pre><p><code>general_inters=general_inters</code> can be given as a keyword argument when setting up the <a href="../api/#Molly.System"><code>System</code></a>.</p><h2 id="Cutoffs"><a class="docs-heading-anchor" href="#Cutoffs">Cutoffs</a><a id="Cutoffs-1"></a><a class="docs-heading-anchor-permalink" href="#Cutoffs" title="Permalink"></a></h2><p>The total potential energy of a system is given as a sum of the individual inter-particle potentials</p><p class="math-container">\[V(\vec{r}_1, \dotsc, \vec{r}_N) = \sum_{i&lt;j}V_{ij}(r_{ij})\]</p><p>The forces acting on the particles are given by</p><p class="math-container">\[\vec{F}_i = -\sum_j \frac{dV_{ij}(r_{ij})}{dr_{ij}}\frac{\vec{r}_{ij}}{r_{ij}}\]</p><p>In the case of the Lennard-Jones potential, the inter-particle potential is given by</p><p class="math-container">\[V_{ij}(r_{ij}) = 4\varepsilon_{ij} \left[\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{12} - \left(\frac{\sigma_{ij}}{r_{ij}}\right)^{6}\right]\]</p><p>and the forces are given by</p><p class="math-container">\[\begin{aligned}
\vec{F}_i &amp;= 24\varepsilon_{ij} \left(2\frac{\sigma_{ij}^{12}}{r_{ij}^{13}} - \frac{\sigma_{ij}^6}{r_{ij}^{7}}\right) \frac{\vec{r}_{ij}}{r_{ij}} \\
&amp;= \frac{24\varepsilon_{ij}}{r_{ij}^2} \left[2\left(\frac{\sigma_{ij}^{6}}{r_{ij}^{6}}\right)^2 -\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{6}\right] \vec{r}_{ij}
\end{aligned}\]</p><p>As the potential, and thus also the force decreases rapidly with the distance, in almost every implementation of the Lennard-Jones force calculation there is a cutoff radius beyond which the force is set to 0.</p><p>While this is often a sensible approach, it introduces a discontinuity in the force function and it requires us to also modify the potential, as beyond the cutoff radius the force would be 0, but the derivative of the unmodified potential is not. One way to truncate the potential is to shift the potential by its cutoff value.</p><p class="math-container">\[\begin{aligned}
\vec{F}_{SP}(\vec{r}) &amp;= \begin{cases}
\vec{F}(\vec{r}), r &lt; r_c \\
0, r &gt; r_c
\end{cases} \\
V_{SP}(r) &amp;= \begin{cases}
V(r) - V(r_c), r \le r_c \\
0, r &gt; r_c
\end{cases}
\end{aligned}\]</p><p>This way the potential function is continuous and the relation between forces and potentials is satisfied. This truncation method is called shifted potential cutoff.</p><p>Another option is to shift the force in order to make it continuous</p><p class="math-container">\[\begin{aligned}
F_{SF}(r) &amp;= \begin{cases}
F(r) - F(r_c), r \le r_c \\
0, r &gt; r_c
\end{cases} \\
V_{SF}(r) &amp;= \begin{cases}
V(r) - (r-r_c) V&#39;(r_c) - V(r_c), r \le r_c \\
0, r &gt; r_c
\end{cases}
\end{aligned}\]</p><p>This requires a more complicated change in the potential in order to satisfy the relation between them. This method is called the shifted force cutoff. The continuity of the force is desirable as it may give better energy conservation properties as shown in <a href="http://aip.scitation.org/doi/10.1063/1.3558787">Toxvaerd 2011</a>.</p><p>There are also more complicated truncation methods that interpolate between the original potential and 0, but we will consider those two for the moment.</p><p>The truncation approximations that we use can significantly alter the qualitative features of the simulation as shown in many articles in the molecular dynamics literature (<a href="https://aip.scitation.org/doi/full/10.1063/1.4997698">Fitzner 2017</a>, <a href="https://pubs.acs.org/doi/10.1021/ct0502256">van der Spoel 2006</a> and others).</p><h3 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h3><p>Since the truncation algorithm is independent of the interaction for which is used, each interaction is defined without including cutoffs. The corresponding interaction <code>struct</code> has a <code>cutoff</code> field which is then used via dispatch to apply the chosen cutoff. The available cutoffs are:</p><ul><li><a href="../api/#Molly.NoCutoff"><code>NoCutoff</code></a></li><li><a href="../api/#Molly.DistanceCutoff"><code>DistanceCutoff</code></a></li><li><a href="../api/#Molly.ShiftedPotentialCutoff"><code>ShiftedPotentialCutoff</code></a></li><li><a href="../api/#Molly.ShiftedForceCutoff"><code>ShiftedForceCutoff</code></a></li></ul><h2 id="Simulators"><a class="docs-heading-anchor" href="#Simulators">Simulators</a><a id="Simulators-1"></a><a class="docs-heading-anchor-permalink" href="#Simulators" title="Permalink"></a></h2><p>Simulators define what type of simulation is run. This could be anything from a simple energy minimisation to complicated replica exchange MD. The available simulators are:</p><ul><li><a href="../api/#Molly.VelocityVerlet"><code>VelocityVerlet</code></a></li><li><a href="../api/#Molly.StormerVerlet"><code>StormerVerlet</code></a></li></ul><p>To define your own simulator, first define a <code>struct</code>:</p><pre><code class="language-julia">struct MySimulator
    # Any properties, e.g. the time step or coupling methods
end</code></pre><p>Then, define the function that carries out the simulation. This example shows some of the helper functions you can use:</p><pre><code class="language-julia">function Molly.simulate!(sys::System,
                            sim::MySimulator,
                            n_steps::Integer;
                            parallel::Bool=true)
    # Find neighbors like this
    neighbors = find_neighbors(sys, sys.neighbor_finder; parallel=parallel)

    for step_n in 1:n_steps
        # Apply the loggers like this
        run_loggers!(sys, neighbors, step_n)

        # Calculate accelerations like this
        accels_t = accelerations(sys, neighbors; parallel=parallel)

        # Ensure coordinates stay within the simulation box like this
        for i in 1:length(sys)
            sys.coords[i] = wrap_coords.(sys.coords[i], sys.box_size)
        end

        # Apply coupling like this
        apply_coupling!(sys, sim, sim.coupling)

        # Find new neighbors like this
        neighbors = find_neighbors(sys, sys.neighbor_finder, neighbors, step_n;
                                   parallel=parallel)
    end

    return sys
end</code></pre><p>To use your custom simulator, give it as the second argument when calling <a href="../api/#Molly.simulate!-Tuple{Any, VelocityVerlet, Integer}"><code>simulate!</code></a>.</p><p>Under the hood there are two implementations for simulators: an in-place version geared towards CPUs and parallelism, and an out-of-place version geared towards GPUs and differentiable simulation. You can define different versions of a simulator for in-place and out-of-place systems by dispatching on <code>System{D, false}</code> or <code>System{D, true}</code> respectively. This also applies to coupling methods and neighbor lists. You do not have to define two versions though: you may only intend to use the simulator one way, or the out-of-place version may be performant in all cases. The above example is more similar to the in-place version; see the source code for an example of the out-of-place version.</p><p>The implementation to use is guessed when you call <a href="../api/#Molly.System"><code>System</code></a> based on whether <code>coords</code> is a <code>CuArray</code> but can be given explicitly with the <code>gpu_diff_safe</code> argument, for example if you want to run differentiable simulations on the CPU. <a href="../api/#Molly.is_gpu_diff_safe-Union{Tuple{System{D, G}}, Tuple{G}, Tuple{D}} where {D, G}"><code>is_gpu_diff_safe</code></a> will retrieve this property for a <a href="../api/#Molly.System"><code>System</code></a>.</p><h2 id="Coupling"><a class="docs-heading-anchor" href="#Coupling">Coupling</a><a id="Coupling-1"></a><a class="docs-heading-anchor-permalink" href="#Coupling" title="Permalink"></a></h2><p>Temperature and pressure coupling allows properties to be controlled during a simulation. The available couplers are:</p><ul><li><a href="../api/#Molly.AndersenThermostat"><code>AndersenThermostat</code></a></li><li><a href="../api/#Molly.RescaleThermostat"><code>RescaleThermostat</code></a></li><li><a href="../api/#Molly.BerendsenThermostat"><code>BerendsenThermostat</code></a></li></ul><p>To define your own coupling method, first define the <code>struct</code>:</p><pre><code class="language-julia">struct MyCoupler
    # Any properties, e.g. a target temperature or coupling constant
end</code></pre><p>Then, define the function that implements the coupling every time step:</p><pre><code class="language-julia">function apply_coupling!(sys::System, sim, coupling::MyCoupler)
    # Do something to the simulation, e.g. scale the velocities
    return sys
end</code></pre><p>The functions <a href="../api/#AtomsBase.velocity-Tuple{Any, Any}"><code>velocity</code></a>, <a href="../api/#Molly.maxwell_boltzmann-Tuple{Any, Any}"><code>maxwell_boltzmann</code></a> and <a href="../api/#Molly.temperature-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}"><code>temperature</code></a> may be useful here. To use your custom coupler, give it as the <code>coupling</code> argument to the simulator.</p><h2 id="Neighbor-finders"><a class="docs-heading-anchor" href="#Neighbor-finders">Neighbor finders</a><a id="Neighbor-finders-1"></a><a class="docs-heading-anchor-permalink" href="#Neighbor-finders" title="Permalink"></a></h2><p>Neighbor finders find close atoms periodically throughout the simulation, saving on computation time by allowing the force calculation between distant atoms to be omitted. The available neighbor finders are:</p><ul><li><a href="../api/#Molly.NoNeighborFinder"><code>NoNeighborFinder</code></a></li><li><a href="../api/#Molly.CellListMapNeighborFinder"><code>CellListMapNeighborFinder</code></a></li><li><a href="../api/#Molly.TreeNeighborFinder"><code>TreeNeighborFinder</code></a></li><li><a href="../api/#Molly.DistanceNeighborFinder"><code>DistanceNeighborFinder</code></a></li><li><a href="../api/#Molly.DistanceVecNeighborFinder"><code>DistanceVecNeighborFinder</code></a></li></ul><p>To define your own <a href="../api/#Molly.AbstractNeighborFinder"><code>AbstractNeighborFinder</code></a>, first define the <code>struct</code>:</p><pre><code class="language-julia">struct MyNeighborFinder &lt;: AbstractNeighborFinder
    nb_matrix::BitArray{2}
    matrix_14::BitArray{2}
    n_steps::Int
    # Any other properties, e.g. a distance cutoff
end</code></pre><p>Examples of three useful properties are given here: a matrix indicating atom pairs eligible for non-bonded interactions, a matrix indicating atoms in a 1-4 bonding arrangement, and a value determining how many time steps occur between each evaluation of the neighbor finder. Then, define the neighbor finding function that is called every step by the simulator:</p><pre><code class="language-julia">function find_neighbors(s::System,
                        nf::MyNeighborFinder,
                        current_neighbors=nothing,
                        step_n::Integer=0;
                        parallel::Bool=true)
    if step_n % nf.n_steps == 0
        if isnothing(current_neighbors)
            neighbors = NeighborList()
        else
            neighbors = current_neighbors
        end
        empty!(neighbors)
        # Add to neighbors, for example
        push!(neighbors, (1, 2, false)) # atom i, atom j and whether they are in a 1-4 bonding arrangement
        return neighbors
    else
        return current_neighbors
    end
end</code></pre><p>A different setup is used for the out-of-place implementation. To use your custom neighbor finder, give it as the <code>neighbor_finder</code> argument when creating the <a href="../api/#Molly.System"><code>System</code></a>.</p><h2 id="Loggers"><a class="docs-heading-anchor" href="#Loggers">Loggers</a><a id="Loggers-1"></a><a class="docs-heading-anchor-permalink" href="#Loggers" title="Permalink"></a></h2><p>Loggers record properties of the simulation to allow monitoring and analysis. The available loggers are:</p><ul><li><a href="../api/#Molly.TemperatureLogger"><code>TemperatureLogger</code></a></li><li><a href="../api/#Molly.CoordinateLogger"><code>CoordinateLogger</code></a></li><li><a href="../api/#Molly.VelocityLogger"><code>VelocityLogger</code></a></li><li><a href="../api/#Molly.TotalEnergyLogger"><code>TotalEnergyLogger</code></a></li><li><a href="../api/#Molly.KineticEnergyLogger"><code>KineticEnergyLogger</code></a></li><li><a href="../api/#Molly.PotentialEnergyLogger"><code>PotentialEnergyLogger</code></a></li><li><a href="../api/#Molly.StructureWriter"><code>StructureWriter</code></a></li></ul><p>To define your own logger, first define the <code>struct</code>:</p><pre><code class="language-julia">struct MyLogger
    n_steps::Int
    # Any other properties, e.g. an Array to record values during the trajectory
end</code></pre><p>Then, define the logging function that is called every step by the simulator:</p><pre><code class="language-julia">function Molly.log_property!(logger::MyLogger, sys, neighbors, step_n)
    if step_n % logger.n_steps == 0
        # Record some property or carry out some action
    end
end</code></pre><p>The use of <code>n_steps</code> is optional and is an example of how to record a property every n steps through the simulation. To use your custom logger, add it to the dictionary of loggers given when creating the <a href="../api/#Molly.System"><code>System</code></a>:</p><pre><code class="language-julia">loggers = Dict(&quot;mylogger&quot; =&gt; MyLogger(10))</code></pre><h2 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h2><p>Molly contains some tools for analysing the results of simulations. The available analysis functions are:</p><ul><li><a href="../api/#Molly.visualize"><code>visualize</code></a></li><li><a href="../api/#Molly.rdf-Tuple{Any, Any}"><code>rdf</code></a></li><li><a href="../api/#Molly.distances-Tuple{Any, Any}"><code>distances</code></a></li><li><a href="../api/#Molly.displacements-Tuple{Any, Any}"><code>displacements</code></a></li><li><a href="../api/#Molly.velocity_autocorr"><code>velocity_autocorr</code></a></li><li><a href="../api/#Molly.rmsd-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, AbstractArray{SVector{D, T}}}} where {D, T}"><code>rmsd</code></a></li></ul><p>Julia is a language well-suited to implementing all kinds of analysis for molecular simulations.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../differentiable/">Differentiable simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 25 February 2022 11:08">Friday 25 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
